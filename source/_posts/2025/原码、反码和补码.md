---
title: 原码、反码和补码
description: 本文介绍了数制系统和计算机定点数的表示方法。从数的进制入手，引入定点数，接着逐步阐述定点数的表示，从原码、反码再到补码，讲解了它们的具体表示、范围和优缺点。
keywords:
  - 原码
  - 反码
  - 补码
  - 定点数
  - 编码
categories:
  - [Computer System,编码]
tags:
  - 原码
  - 反码
  - 补码
  - 定点数
abbrlink: '23e07058'
date: 2025-03-03 18:49:01
updated: 2025-07-03 22:51:01
katex: true
---
## 数的进制：基数和权

先看任意的一个 R 进制数（R 是正整数）：$A = a_n a_{n-1} \cdots a_1 a_0 . a_{-1} a_{-2} \cdots a_{1-m} a_{-m}$

其值都可以通过以下方式求得：

$Value(A) = \sum_{i=-m}^{n} a_i \times R^i$

R 被称为**基数**，表示 R 进制数每个数位上可以使用的不同数字的数量。$R^i$ 称为第 i 位上的**权**，即逢 R 进 1。二进制就是 R=2 的情况。

> 根据上述定义可以推出二进制转 16 进制的做法：从小数点开始向左和向右两个方向每 4 位数为 1 组替换为一个 16 进制数。16 进制转二进制同理，每个 16 进制位替换为 4 个二进制位。
> 
> 如二进制101001.01转为16进制就是29.4

计算机不能表示真的小数点，但是可以通过约定小数点的位置来解决这个问题。

## 定点数的表示

小数点的位置约定在固定位置的数称为**定点数**，否则称为**浮点数**，本文只介绍定点数表示法——原码、反码和补码。

纯二进制规则无法表示有符号数，原码、反码与补码的出现解决了符号表示问题。

### 原码

英文术语：Sign-Magnitude

原码表示法：数的原码采用“符号-数值”的表示方式，即一个形如 $A = a_{n-1} a_{n-2} \cdots a_1 a_0$ 的原码表示，最高位 $a_{n-1}$ 是符号位，其为 0 表示整数，为 1 表示负数，其余位表示数值的绝对值。

例如，在 8 位二进制表示中：

+ 10000000<sub> 原</sub> 表示整数 -0，00000000<sub> 原</sub>表示 +0
+ 表示范围：\[-127, 127]，即 \[-(2<sup>7</sup>-1), 2<sup>7</sup>-1]

使用原码的好处是直观、容易理解，但也存在明显缺陷：

+ 存在两个 0，即一个 +0，一个 -0。
+ 减法需要专门的硬件逻辑来处理，增加了硬件负担。

> 计算机中只存在加法器，所以原码做减法需要额外处理——要判断符号位，以及做绝对值计算。形如 A - B 这样的运算，需转换为 A + (-B)，其值为 $((|A| - |B|) ? + : -) ||A| - |B||$。

### 反码

英文术语：Ones' Complement

反码表示法：对于正数，其反码与原码相同；而对于负数，则保持符号位不变，其余各位按位取反（0 变 1，1 变 0）。  

---

对于 4 位二进制的原码及反码表示：

| 整数  |  原码  |  反码  |
| :-: | :--: | :--: |
| +0  | 0000 | 0000 |
| -0  | 1000 | 1111 |
| -1  | 1001 | 1110 |
| -2  | 1010 | 1101 |
| -4  | 1100 | 1011 |

1 - 1 = 1 + (-1) = 0001<sub>反</sub> + 1110<sub>反</sub>  = 1111<sub>反 </sub>= -0

2 - 1 = 2 + (-1) = 0010<sub>反</sub> + 1110<sub>反</sub>  = 1<sub>舍</sub>0000<sub>反 </sub>--修正--> 0001<sub>反 </sub>= 1

1 - 2 = 1 + (-2) = 0001<sub>反</sub> + 1101<sub>反</sub>  = 1110<sub>反</sub> = -1 

3 - 1 = 3 + (-1) = 0011<sub>反</sub> + 1110<sub>反</sub>  = 1<sub>舍</sub>0001<sub>反 </sub>--修正--> 0010<sub>反</sub> = 2

4 - 1 = 4 + (-1) = 0100<sub>反</sub> + 1110<sub>反</sub> = 1<sub>舍</sub>0010<sub>反</sub>  --修正--> 0011<sub>反</sub> = 3

-4 - 0 = (-4) + (-0) = 1011<sub>反</sub> + 1111<sub>反</sub> = 1<sub>舍</sub>1010<sub>反</sub>  --修正--> 1100<sub>反</sub> = -4

> 需对结果加 1 循环进位进行修正。

---

8 位二进制反码的范围：

- 正数范围：00000000 到 01111111，即 \[0，$2^7 -1$]
- 负数范围：11111111 到 10000000，即 \[-0，$-2^7 + 1$]


反码解决了原码的减法问题：A - B 可以转化为 A + (-B)，原码符号位需要单独处理，反码符号位直接参与计算。

缺陷：

1. 反码减法结果需要加 1 修正；
2. 没有解决“双零”问题。

### 补码

英文术语：Two's Complement

补码表示法：正数补码与原码相同；负数补码是反码加 1。任何数加上其补码其值都为 0。

求一个数的补码是个取模运算。最为常见的模运算系统的例子是时钟，这个模系统的模数为 12，假定现在时钟指向 6 点，需要将其拨向 10 点，那么有两种做法，一种是顺时针拨 4 小时，一种是逆时针拨 8 小时，用数学语言解释就是 $4 \equiv -8\ (mod \ 12)$。利用补码基于模运算的这个特点，可以把减法转换成加法来做，因此在计算机中不用把加法器和减法器分开，只要有加法器就可以做减法。

基于模运算系统的概念，对于具有 1 位符号位和 n-1 位数值位的 n 位二进制整数的补码来说，其定义是：

$$
[X]_\text{补} = (2^{n} + X)\ (mod\ 2^{n}),\ -2^{n-1} \leqslant  X \leq 2^{n-1}-1,0\leq [X]_\text{补}\leq 2^{n}-1
$$

4 位二进制数负数的原码、补码如下：

| 原码       | 补码       |
| -------- | -------- |
| 1000（-0） | 0000（0）  |
| 1001（-1） | 1111（15） |
| 1010（-2） | 1110（14） |
| ...      | ...      |
| 1111（-7） | 1001（9）  |

对于 8 位二进制补码，其范围为：

- 正数范围：00000000 到 01111111，即 \[0，$2^7 -1$ = 127]
- 负数范围：11111111（255） 到 10000000（128），这里使用模运算计算，即 \[255 - 256 = -1，128 - 256 = -128]
- 综合范围：\[-128, 127]