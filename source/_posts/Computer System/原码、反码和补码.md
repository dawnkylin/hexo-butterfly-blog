---
title: 原码、反码和补码
date: 2025-03-03 18:49:50
updated: 2025-03-11 18:49:50
tags:
  - Code
  - 编码
categories:
  - Computer System
keywords:
description:
top_img:
cover: https://raw.githubusercontent.com/dawnkylin/images/main/2025/20250312134745584.png
commets:
katex:
aplayer:
---

## 计算机的二进制编码

为什么计算机系统采用二进制编码？因为**制造有两个稳定状态（电压高低、脉冲正负等）的物理器件要比制造有多个稳定状态的物理器件容易得多**，有两个稳定状态的物理器件就能表示一个二进制位。
先看任意的一个 R 进制数（R 是正整数）：

$A = a_n a_{n-1} \cdots a_1 a_0 . a_{-1} a_{-2} \cdots a_{1-m} a_{-m}$

其值都可以通过以下方式求得：

$Value(A) = a_n \times R^{n} + a_{n-1} \times R^{n-1} + \cdots a_1 \times R^{1} + a_0 \times R^{0} + . a_{-1} \times R^{-1} + a_{-2} \times R^{-2} + \cdots a_{1-m} \times R^{1-m} + a_{-m} \times R^{-m}$

R 被称为基数，表示 R 进制数每个数位上可以使用的不同数字的数量。$R^i$称为第 i 位上的权，即逢 R 进 1。二进制就是 R=2 的情况。

根绝上述定义也可以推出二进制转 16 进制的做法：从小数点开始向左和向右两个方向每 4 位数为 1 组替换为一个 16 进制数。16 进制转二进制同理，每个 16 进制位替换为 4 个二进制位。

但要注意上述的定义只适合无符号数，因此需要新的编码规则来扩大表示范围。


## 定点数的表示

可以通过约定小数点的位置来解决计算机不能表示小数点的问题，小数点的位置约定在固定位置的数称为**定点数（整数）**，否则称为**浮点数（实数）**，本文只介绍定点数表示法——原码、反码和补码。

前面说了二进制原生编码方式无法表示有符号整数，原码、反码与补码则解决了符号表示问题。

### 原码

英文术语：Sign-Magnitude

原码表示法：数的原码采用“符号-数值”的表示方式，即一个形如$A = a_{n-1} a_{n-2} \cdots a_1 a_0$的原码表示，最高位$a_{n-1}$是符号位，其为 0 表示整数，为 1 表示负数，其余位表示数值的绝对值。

例如，在 8 位二进制表示中：

+ 10000000<sub> 原</sub> 表示整数 -0，00000000<sub> 原</sub>表示 +0
+ 表示范围：[-127, 127]，即 [-(2<sup>7</sup>-1), 2<sup>7</sup>-1]

使用原码的好处是直观、容易理解，但也存在明显缺陷：

+ 存在两个 0，即一个 +0，一个 -0。
+ 减法需要专门的硬件逻辑来处理，增加了硬件负担。

> 计算机中只存在加法器，所以原码做减法需要额外处理——要判断符号位，以及做绝对值计算。形如 A - B 这样的运算，需转换为 A + (-B)，其值为$((|A| - |B|) ? + : -) ||A| - |B||$。

### 反码

英文术语：Ones' Complement

反码表示法：对于正数，其反码与原码相同；而对于负数，则保持符号位不变，其余各位按位取反（0 变 1，1 变 0）。  

---

对于 4 位二进制的原码及反码表示：

| 整数 | 原码 | 反码 |
| :---: | :---: | :---: |
| +0 | 0000 | 0000 |
| -0 | 1000 | 1111 |
| -1 | 1001 | 1110 |
| -2 | 1010 | 1101 |
| -4 | 1100 | 1011 |


1 - 1 = 1 + (-1) = 0001<sub>反</sub> + 1110<sub>反</sub>  = 1111<sub>反 </sub>= -0

2 - 1 = 2 + (-1) = 0010<sub>反</sub> + 1110<sub>反</sub>  = 1<sub>舍</sub>0000<sub>反 </sub>--修正--> 0001<sub>反 </sub>= 1

1 - 2 = 1 + (-2) = 0001<sub>反</sub> + 1101<sub>反</sub>  = 1110<sub>反</sub> = -1 

3 - 1 = 3 + (-1) = 0011<sub>反</sub> + 1110<sub>反</sub>  = 1<sub>舍</sub>0001<sub>反 </sub>--修正--> 0010<sub>反</sub> = 2

4 - 1 = 4 + (-1) = 0100<sub>反</sub> + 1110<sub>反</sub> = 1<sub>舍</sub>0010<sub>反</sub>  --修正--> 0011<sub>反</sub> = 3

-4 - 0 = (-4) + (-0) = 1011<sub>反</sub> + 1111<sub>反</sub> = 1<sub>舍</sub>1010<sub>反</sub>  --修正--> 1100<sub>反</sub> = -4

> 需对结果加 1 循环进位进行修正。
>

---

8 位二进制反码的范围：

- 正数范围：00000000 到 01111111，即 [0，$2^7 -1$]
- 负数范围：11111111 到 10000000，即 [-0，$-2^7 + 1$]


反码解决了原码的减法问题：A - B 可以转化为 A + (-B)，原码符号位需要单独处理，反码符号位直接参与计算。

缺陷：

1. 反码减法结果需要加 1 修正；
2. 没有解决“双零”问题。

### 补码

英文术语：Two's Complement

补码表示法：正数补码与原码相同；负数补码是反码加 1。任何数加上其补码其值都为 0。

求一个数的补码是个取模运算。最为常见的模运算系统的例子是时钟，这个模系统的模数为 12，假定现在时钟指向 6 点，需要将其拨向 10 点，那么有两种做法，一种是顺时针拨 4 小时，一种是逆时针拨 8 小时，用数学语言解释就是$4 \equiv -8\ (mod \ 12)$。利用补码基于模运算的这个特点，可以把减法转换成加法来做，因此在计算机中不用把加法器和减法器分开，只要有加法器就可以做减法。

基于模运算系统的概念，对于具有 1 位符号位和 n-1 位数值位的 n 位二进制整数的补码来说，其定义是：

$[X]_{\text{补}} = (2^{n} + X)\ (mod\ 2^{n}),\ -2^{n-1} \leqslant  X \leq 2^{n-1}-1,0\leq [X]_{\text{补}}\leq 2^{n}-1$

4 位二进制数负数的原码、补码如下：


| 原码 | 补码 |
| --- | --- |
| 1000（-0） | 0000（0） |
| 1001（-1） | 1111（15） |
| 1010（-2） | 1110（14） |
| ... | ... |
| 1111（-7） | 1001（9） |


对于 8 位二进制补码，其范围为：

- 正数范围：00000000 到 01111111，即 [0，$2^7 -1$= 127]
- 负数范围：11111111（255） 到 10000000（128），这里使用模运算计算，即 [255 - 256 = -1，128 - 256 = -128]
- 综合范围：[-128, 127]